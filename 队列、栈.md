# #队列

## ##leetcode225、232、406、622、641、899、1670、1944

### ###leetcode225用队列实现栈

1.函数定义

（1）void push(int x) 将元素 x 压入栈顶；
（1）int pop() 移除并返回栈顶元素；
（1） int top() 返回栈顶元素；
（1） boolean empty() 如果栈是空的，返回 true ；否则，返回 false 

2.思路

（1）创建两个队列 q1，q2；

（2）入栈：将元素 x 直接放入 q1 队列中；

（3）出栈：也就是把 q1 的队尾元素出队列，由于队列只能从队头出队，因此先把 q1 中除了队尾元素的其他值存到 q2 中，再把队尾元素也就是栈顶出队，最后将 q2 中的值存到 q1 中；

（4）获取栈顶元素：获取 q1 的队尾元素

### ###leetcode232用栈实现队列

1.函数定义

（1）push(x) – 将一个元素放入队列的尾部；

（2）pop() – 从队列首部移除元素；

（3）peek() – 返回队列首部的元素；

（4）empty() – 返回队列是否为空

2.思路

（1）使用两个栈，先把数据放入一个栈中然后再依次取出放入到另一个栈中，如：队列是 1->2->3；

（2）使用栈实现，先用栈a 存放1->2->3,然后再导入到另一个栈 b中，因为栈是后进先出所以栈b为 3->2->1；

（3）栈b 不为空直接pop，否则把栈a 的所有元素放到栈b 然后执行栈b的 pop操作。push操作只需要向栈a中push就行。

### ###leetcode324

1.思路

（1）首先，将无序数组进行排序，并将排序后的结果分为大数和小数两个部分，为了得到nums [0] &lt; nums[1] &gt; nums[2] &lt; nums[3] . . . . nums[0]&lt;nums[1]&gt;nums[2]&lt;nums[3].... nums[0]<nums[1]>nums[2]<nums[3]....这样的摆动队列，我们从大数和小数集合中交替插入数据，产生一个新的序列；

（2）此外，在划分大数部分和小数部分时，要求后者的序列长度不小于前者。

### ###leetcode406

1.思路

（1）先排序再插入，插入的过程是贪心的过程，贪心就是保持每一阶段的局部最优，最后达到全局最优；

（2）先按照身高由高到低排列，所以身高的索引加了负号，身高相同的按k排列，大的放后边，k表示的是前面有k个身高大于或者等于h的人。按身高排好以后，从前到后遍历，将数组插入到合适的位置，先实现局部最优，再达到全局最优，最终构造完成队列。

2.复杂度

（1)**时间复杂度**是n的平方，因为排序的时间复杂度是nlogn，插入的过程需要遍历全部数组，并且插入一个数需要移动其他数，所以时间复杂度是n的平方，它大于排序的时间复杂度。
 （2）**空间复杂度**来自排序过程使用的栈空间。

### ###leetcode622

思路：

（1）设计循环队列的实现中，当队列满时，tail指向的位置是没有数据的，也就是数组中有一个位置是闲置浪费的，显然当时那个思路不适合本题目。

（2）整体思路与之前仍然是一样的，只是需要改变判断队列空或者满的条件。我们再添加一个 count 的变量，来记录队列中元素的个数。当元素个数等于我们最开始定义的数组长度时，队列满；当元素个数等于零，队列空。

（3）当队列头或者尾索引值到达数组上限时，需要再从零开始。可以用一个除余来实现，head = (head + 1) % len，索引值就会自动进行循环。

（4）在这样的设计下，队列头索引值始终指向队列的第一个元素，但队列尾索引值减一*才指向队列的最后一个元素，而且当队尾索引值为零时，“减一”后应该指向数组的最后一个元素。

### ###leetcode641

1.函数定义

（1）MyCircularDeque(k)：构造函数,双端队列的大小为k；
（2）insertFront()：将一个元素添加到双端队列头部。如果操作成功返回 true。
（3）insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。
（4）deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。
（5）deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。
（6）getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。
（7）getRear()：获得双端队列的最后一个元素。如果双端队列为空，返回 -1。
（8）isEmpty()：检查双端队列是否为空。
（9）isFull()：检查双端队列是否满了。

2.思想

（1）定义队列、头尾指针和队列长度。

（2）插入队列头尾的函数要判断队列是否已满，而删除队列头尾的函数要判断队列是否为空。

### ###leetcode899

1.思想

（1）假如能够证明序列里任意相邻字母都可以交换，那肯定可以直接排出最小值

（2）当K>1时，我们想交换S[i]和S[i+1]，那么操作出S[i:]+S[:i]，然后，由于K至少为2，所以这时候可以先把S[i+1]放到后面去，变成S[i]+S[i+2:]+S[:i]+S[i+1]，然后再放S[i]，得到S[i+2:]+S[:i]+S[i+1]+S[i]，最后再依次把S[i+2:]这部分移回去就好，得到S[:i]+S[i+1]+S[i]+S[i+2:]，完成交换
（3）当K=1时，就不行了，我们只能得到S的rotation，从里面找一个最小的就好

### ###leetcode1944

思想：单调栈

（1）相当于每一个人找右侧第一个比他高的人；

（2）那么维护一个单调递减的栈。进栈时，如果当前的人高于栈顶的人，则说明栈顶的人已经找到第一个比他高的人，出栈。出栈时答案加 1，因为要算上这个比他高的人；

（3）在新的人进栈时，且不为空, 其进栈前栈顶的人答案加 1，因为当前栈顶肯定可以看到刚进栈的人,但不是栈顶的人肯定看不到,因为每个人只能看到一个单调上升的序列

时间复杂度：每个人最多进栈一次，出栈一次，故总时间复杂度为 O(n)。
 空间复杂度：需要 O(n)的额外空间存储单调栈。